Фреймворк - это универсальное средство, которое содержит функционал, востребованный в разных проектах. Проекты могут быть разной сложности: сайт-визитка, интернет-магазин, платформа для онлайн-игр; и разной тематики: продажа автомобилей, фан-клуб Джонни Кейджа, CRM-система. Фреймворк предназначен для того чтобы создать быстро и качественно любой из этих проектов, по сути ускорение и упрощение конечной разработки.

Время от времени становится лень делать какие-либо вещи и приходят просьбы или требования включить одну или другую функциональность во фреймворк. В идеологии фреймворка это и заложено - обеспечить скорость разработки за счёт переноса повторяющихся действий и автоматизаций во фреймворк. Однако здесь объясняется какой функционал не может быть включён во фреймворк и почему.

## Опасный для стабильности проекта

[Здесь статья по оптимизации нагрузки](Дополнительно/Оптимизация нагрузки). Код, который потенциально может нагрузить систему так, что она будет падать или долго отвечать - не будет включён в CRUD систему фреймворка. Если нужно это обойти, тогда стоит переопределять методы фреймворка или писать новые энд-поинты.

Понятно, что тот код, который существует во фреймворке, можно нагрузить так, что система рухнет. Но, при проектировании каких-то функций во фреймворке, мы исходим из парадигмы разумности. Это значит, что в большинстве случаев код будет работать надёжно.

Поиск и отдача сущностей спроектированы так, что они имеют ограничения на количество передаваемых данных. Если система, которая создаётся на базе фреймворка, спроектирована так, что она должна отдавать данные в том объёме, который может быть потенциально опасен для других систем, тогда эта задача решается средствами этой системы, а не фреймворком.

## Не универсальный

Кодовая база, поставляемая с фреймворком, должна быть универсальна. Она не зависит от какого-то конкретного проекта и предназначена для использования в разных проектах. К примеру, если требуется предоставление данных в каком-то определённом формате, эта задача может быть рассмотрена разработчиками фреймворка и в некоторых случаях включена во фреймворк при условии что этот формат достаточно универсален и может быть с большой вероятностью использован где-то ещё.

Пример функционала который может быть включён во фреймворк: универсальный модуль экспорта данных в каком-либо формате (CSV, XML, XLS), хранение и обработка изображений, форматирование дат и времени, специфический формат валидации, формирование ссылок на Google Maps и так далее.

Пример функционала, который не будет включён во фреймворк: общение с API Сбербанка, движок блогов или форумов, обработка потокового видео, расчёт фаз состояния луны и тому подобное.

Если кажется, что какой-либо функционал должен быть во фреймворке, но разработчики фреймворка считают иначе, то, вероятно, этот функционал стоит разработать и поместить в отдельную библиотеку, которая может быть использована в других проектах. Нужно всегда помнить о том, что фреймворк содержит только общий функционал.

## Временный

Во фреймворк вносится только код, который универсален и будет использоваться годы вперёд. Это значит, что K&V программирование в нём исключено. Код, который требуется во фреймворке, всегда проектируется с расчётом на будущее.

Исключение могут составлять только ситуации, описанные ниже.

Есть пониманимание что этот функционал нужен, но как он будет конкретно использоваться - неизвестно, тогда двигаемся на ощупь. В данном случае пишется временный код, который проходит обкатку, набирается опыт и формируется нужный качественный функционал. Такое может происходить, к примеру, когда нет чёткого задания на функционал, а такое бывает часто. В данном случае есть высокий риск получить изменение работы API.

В случае, если функционал критичен, но нельзя продумать его основательно из-за недостатка времени, так как рилиз уже через полчаса и вообще это должно быть реализовано ещё вчера, а телепатов под боком не оказалось. Такое часто бывает, это бизнес, детка. В данном случае пишется код, который быстро закроет требования в необходимой функции, но тут же создаётся задача с рефакторингом и описанием того что нужно будет сделать и что ожидается в результате.

## Жёсткий

Код фреймворка не может быть жёстким, не должен содержать в себе хардкод. Всё в идеале должно иметь возможность быть переопределено и расширено. Если есть какой-то функционал, который должен быть во фреймворке, то он должен иметь возможность быть расширенным другим алгоритмом обработки, который определит программист, пользующийся фреймворком.

Расширить и переопределить можно всё, начиная от настроек фреймворка, конкретных классов, до библиотек.

Исключение составляет лишь ядро фреймворка, которое должно быть быстрое и работать без ошибок. На текущий момент это проект web и консольная команда mq:run, которая и запускает демон обработки очереди сообщений.

Понятно то, что мир не идеален и сделать всё максимально гибким невозможно. По возможности, когда есть понимание как сделать код более гибким, это делается. Мы всегда ищем способы улучшения.

## Сложный код

Принцип написания кода фреймворка - это простота использования и низкое количество ошибок. Двигаться в сторону усложнения кода фреймворка приведёт к увеличению количества ошибок в геометрической прогрессии. Как со стороны фреймворка так и на использующих его проектах. Многие упрощения для пользователей фреймворка должны делаться так, чтобы не делать код сложнее, чем он есть.

Есть некоторые задачи, которые могут быть решены только усложнением кода, тогда они должны быть перенесены в трейты, модули и так далее для упрощения работы с необходимым функционалом. Если код требует усложнения - это всегда место, где стоит подумать о том, стоит ли такой код включать во фреймворк.

Некоторый код и некоторые идеи не могут быть применены во фреймворке всего лишь потому что будет слишком сильное усложнение кода и становится сложно проследить логику и провести отладку.

## Не соответствующий

Приложение на базе Egal Framework состоит из двух частей: фронт-енд и бэк-енд. Первое работает на стороне клиента, второе - на стороне сервера. Эти приложения совместны, но они разделены и не должны содержать в себе куски друг друга. К примеру, фронт-енд не должен содержать SQL запросов, а бэк-енд не должен содержать в себе куски JS и HTML. Тот код, что касается каждого отдельного приложения должен находиться там, где его место.

Например. Не допускается размещение названий, изображений, файлов приложения внутри компонентов фреймворка. Логические части фреймворка и приложения должны быть разделены, для этого есть composer, который скачивает библиотеки фреймворка и даёт возможность их использовать приложением. Данные сущностей не должны быть частично в базе данных, частично во фронт-енд приложении. Создавать энд-поинт, возвращающий пустоту, только для того, что это удобно фронт-энд разработчикам. И так далее.