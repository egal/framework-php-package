Каждый демон обрабатывает несколько очередей параллельно, это обеспечивается многопоточностью приложения. Для параллельной обработки каждой очереди можно разнести сервис по нескольким нодам, а те очереди, которые должны обрабатываться последовательно, заблокировать на всех нодах, кроме одной.

Запуск параллельных процессов происходит функцией [pcntl_fork()](https://www.php.net/manual/ru/function.pcntl-fork.php), которая аналогична функции fork() в языке C. Стоит иметь ввиду, что fork() создаёт новый процесс, копируя существующий, то есть все ресурсы и все данные будут одинаковыми на обоих сторонах. Для этого переинициализируется в дочернем процессе соединение с серверами Redis и БД, возможно потребуются новые переинициализации в будущем. Нужно понимать, что после форка, в процессе работы параллельных процессов, изменённые данные в одном процессе не будут изменены в другом.

Мастер-демон контролирует работу собственных дочерних процессов и, в случае падения одного из них, вызывает колбэк из Session::getQueueFaultCallback(), который выставляется в /bootstrap/; затем поднимает процесс обратно. Дочерние процессы не способны запускать свои собственные.

Процессы контролируются на двух сторонах: микросервисе web и микросервисе-обработчике. В первом случае используется параметр окружения QUEUE_POOL_MANAGER, который устанавливает ограничения на автоматическое создание очередей для обработки. Во втором случае - ручной контроль процессов из командной строки, позволяющий создавать очереди сообщений для обработки вручную ```artisan mq:pool```, а так же осуществлять контроль за тем, какие очереди будут обрабатываться мискросервисом.

Команда artisan mq:pools обзавелась дополнительно следующими параметрами:

* -a - добавить очередь, которую можно слушать
* -d - удалить очередь
* -m - список слушаемых очередей

Если файл pools.json пуст, то обслуживаться будут все очереди.