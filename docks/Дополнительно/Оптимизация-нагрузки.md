Бывают задачи, которые тяжелы для системы в целом. Определить их узкие места достаточно легко, они могут быть четырёх основных типов:

1. **Оперативная память** не бесконечна, данных может быть много загружено в оперативную память из базы, диска или откуда-то ещё
1. **Нагрузка на процессор**, его ресурс тоже конечен, это, как правило, сложные алгоритмы обработки данных, большой объём данных для обработки и так далее
1. **Нагрузка на сеть**, сеть - это тоже тип ресурса, который конечен, это запросы ко внешним сервисам, агрегация данных, внутренний обмен данными и прочее
1. **Дисковая подсистема** также конечна и стоит предусматривать возможность расширения

Все эти задачи могут вызвать отказ в обслуживании и, как следствие, потерю части посетителей сайта, что скажется на прибыльности проекта. Разберём каждый тип по отдельности.

## Оперативная память

Первое, что нужно сделать, это представить, что пользователь запрашивает данные по тому алгоритму, который заложен в ваш код. В данном случае стоит подумать о том, что данных может быть много, они загружаются в оперативную память сервера и только потом передаются пользователю (HTTP протокол, REST API и так далее).

Тут нужно иметь ввиду три фактора:

1. Сервер имеет ограничение оперативной памяти и то, что берётся из хранилища, хранится в памяти до момента окончания передачи клиенту,  а канал может быть узкий, например GSM Edge
1. PHP имеет ограничение выделяемой памяти на скрипт с целью предотвращения угрозы "съедания" всей свободной памяти сервера
1. Скрипт может работать параллельно в виде нескольких процессов, обрабатывая один и тот же запрос от нескольких клиентов, что кратно увеличивает количество используемой памяти

Такие задачи разрешаются просто: надо разбить выдачу данных на отдельные части, например постраничным выводом, принудительной фильтрацией или попросту отказом отдавать большой объём данных. И увеличением количества оперативной памяти сервера и ограничений PHP, если задача не может быть решена по-другому.

Бывает такое, что нужно получить все данные сразу и одним запросом. В некоторых случаях это хорошо и нужно. Но, прежде чем такое сделать, стоит подумать о том, как часто такие данные будут отдаваться и кому, хватит ли на это ресурсов сервера.

## Процессор

Иногда нужно создать сложный алгоритм обработки данных или математических вычислений. Например подсчёт результатов статистики. Такие задачи имеют ограничение в виде процессорного времени, то есть времени на обработку. Эти задачи, при распараллеливании их на несколько клиентов, начинают кратно занимать процессорное время и тратить его на обработку одних и тех же данных одним и тем же алгоритмом, отнимая всё процессорное время системы.

Такие задачи решаются оптимизацией обработки и хранения данных. Например проводить предварительные рассчёты и складывать их в БД. Это позволит иметь заранее готовый результат обработки. Также можно использовать встроенные средства СУБД, которая находится физически ближе к самой БД, для проведения предварительных вычислений встроенными функциями и предоставления уже предподготовленных данных в результатах запроса.

Но бывают такие ситуации, когда расчёты имеют под собой постоянно изменяющиеся данные, которые нужно пересчитывать каждый раз по отдельности для каждого клиента и часто. В таких случаях заранее расчитывается часть данных алгоритма, переводя их в статический вариант в базе. Если такой возможности нет, то часть наиболее статичных данных переводится в кэш в оперативной памяти и сбрасывается (перерасчитывается отдельно) при поступлении изменений. Таким кэшем могут быть такие сервисы как Redis или memcached. И как последний вариант - кластеризация расчётов, перенося их на отдельные вычислительные мощности.

## Сеть

Бывают задачи, когда нужно провести анализ и сбор данных из сети и предоставить результат обработки этих данных. Это могут быть различные агрегаторы или, к примеру, данные, полученные по REST API другого сервиса. Обращение к стороннему сервису требует времени отправки и получения запроса из сети. Пожалуй, это самый простой тип по оптимизации.

В случае агрегаторов задача решается просто: создаётся отдельный сервис, который собирает данные, анализирует и складывает в базу, а основной сервис пользуется уже готовым результатом. Тут всё просто. Но бывают случаи, когда надо получать оперативные данные от стороннего сервиса, использовать их в расчётах, и не менее оперативно предоставить их пользователю.

Такие запросы кэшируются с определённым временем жизни кэша, когда в кэше не найдено - берём от удалённого сервиса. К примеру, данные по регистрации транспортного средства можно кэшировать на 10 дней и предоставлять данные из кэша. Обновлять такие данные более новой версией до окончания срока действия кэша можно или по запросу клиента, или в результате специального запроса к сервису, который скажет что необходимо обновление.

## Дисковая подсистема

Оптимизация дисковой подсистемы, как правило, рассматривается в тех случаях, если есть большой объём данных или обработка данных требует постоянной записи на диск. Такие ситуации бывают достаточно редки, однако, если, к примеру, есть сервер обработки и хранения изображений, может стать актуальным.

Оптимизация скорости работы с диском может быть произведена либо аппаратными методами, либо программными. Аппаратный способ включает в себя установку, к примеру, RAID 10. Программный способ - это кэширование в памяти данных до обработки и при чтении. Смежный способ - это распределение данных в кластере, когда данные лежат на разных серверах и программное обеспечение умеет работать с этим кластером.

В случае использования большого объёма пространства, используется кластеризация или установка дополнительных массивов хранения данных. А в случае, если обработка данных занимает много времени - стоит перенести её на отдельный сервер, который будет обрабатывать эти данные постепенно, давая возможность основной системе работать стабильно.

В процессе разработки информационной системы стоит заранее продумать что будет в случае, если закончится пространство на диске или его скорость записи, и предусмотреть возможности расширения заранее, заложив в код возможности кэширования и распределения данных в кластере.