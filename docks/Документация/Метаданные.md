Метаданные - это структура, на которой основывается практически вся работа во фреймворке:

* Генерируются модели
* Генерируются миграции
* Происходит валидация данных
* Формируется вывод API

В коде к метаданным можно обратиться из модели, у каждой модели есть ссылка на собственные метаданные в виде `$this->metadata`. Получить метаданные по названию модели можно при помощи `Session::getMetadata($modelName)`, см. app/models.json, в этом случае выборка идёт по ключам.

## Построение метаданных

При создании метаданных командой artisan mk:metadata, создаётся файл метаданных с базовыми свойствами и конструктором, где описываются поля, фильтры и отношения.

Для описания полей сущности используется массив $data, для фильтров $filterFields, для отношений $relations. В массиве $relations используется ключ для идентификации отношения в коде, он может содержать в себе как название модели, так и случайное название, которое будет удобно использовать.

Если используется какая-то логика внутри метаданных, то стоит её вынести в отдельные методы, так как конструктор метаданных нужен только для описания.

Отношения в Laravel и отношения во фреймворке - это разные вещи, но оба способа вполне можно использовать безо всяких конфликтов. При этом нужно учитывать то, что на основе отношений, используемых в метаданных, работает CRUD-система фреймворка. Внутри моделей есть трейты Tree и Relation, которые позволяют выполнять действия, основанные на отношениях в метаданных. Отдельно эти трейты подключать не надо, т.к. они уже подключены к модели фреймворка.

## Построение связей

Связи бывают четырёх типов:

* RelationType::MANY_TO_MANY - многие ко многим
* RelationType::ONE_TO_ONE - один к одному
* RelationType::ONE_TO_MANY - один ко многим
* RelationType::BELONGS_TO - относится к

Все отношения в массиве $relations, кроме многие ко многим, описываются так:

`'RelationName' => new Relation(RelationType::RELATION_TYPE, 'User');`

Если указывается поле идентификатора сущности в метаданных (массив $data), например user_id, то она указывается так:

`'user_id' => (new Field(FieldType::RELATION, 'User Readable Field Name'))->setRelation('User')`

В методе Field::setRelation() указывается ключ из массива Metadata::$relations. Отношения типа BELONGS_TO и MANY_TO_MANY не будут являться реальными полями, они не будут фигурировать ни при сохранении, ни при генерации миграции и имеют всегда статус readonly.

У выборки по отношениям есть свои лимиты. В параметрах окружения .env можно установить DEFAULT_MAX_RELATIONS, по-умолчанию оно равно 100. Для каждой роли в отдельности можно выставить другое ограничение, в результате будет браться максимальное ограничение, которое было найдено для всех ролей пользователя. Установить ограничение для роли можно в директории bootstrap:

`Settings::setMaxRelationsByRole('role', 100);`

Роли могут быть в том числе и системные, такие как @all или @logged.

Теперь разберём каждую связь по отдельности.

### Многие ко многим

Такой тип связей выставляется когда, к примеру, пользователь может входить в разные команды и в разных командах есть разные пользователи. В данном случае есть промежуточная таблица, которая содержит в себе идентификаторы обеих сущностей. В метаданных для сущности Team (команда) в массиве $relations указывается так:

`'UserTeam' => new Relation(RelationType::MANY_TO_MANY, 'User', 'UserTeam');`

Где User - это название модели пользователей, а UserTeam - это промежуточная связывающая модель. Название модели UserTeam, или TeamUser, или UserConnectionToTeam не имеет значения, главное - чтобы эта сущность существовала.

Промежуточная сущность содержит в себе поля user_id и team_id, которые формируются так: `Str::snake($modelName) . '_id'`

### Один к одному

Данная связь подразумевает в себе то, что у мастер-сущности содержится поле с id дочерней сущности, то есть у сущности User есть team_id, а у Team есть user_id. Тогда пользователь может принадлежать только одной команде, а в команде может быть только один пользователь.

### Один ко многим

Она похожа на предыдущую, связь один к одному, только у мастер-сущности не указывается id дочерней сущности. Например, у пользователя есть team_id, а у команды поля user_id нет, соответственно, пользователь сможет входить только в одну команду, а в команде может быть множество пользователей. Такой вид связи указывается в данном случае у сущности Team.

### Принадлежит к

Ситуация, обратная предыдущей, она указывается в метаданных User, когда у пользователя есть team_id, а у команды нет user_id. Таким образом мы находим связанную сущность по полю team_id у пользователя.

## Как строится дерево

Дерево вызывается для любой модели через метод getTree(). Построение дерева возможно только в том случае, если указано в метаданных `$showTree = true` и свойство метаданных $treeRelation содержит в себе объект класса Relation, который указывает какой будет следующая модель. Процесс построения дерева переходит дальше к следующей модели и смотрит на наличие того же указания класса в метаданных там.

Например:

![tree_relation](uploads/294245142ebb25d822328ba53eb2cb71/tree_relation.png)

*Пример дерева отношений*

Соответственно, у Team:

`$this->treeRelation = new Relation(RelationType::ONE_TO_MANY, 'User');`

У User:

`$this->treeRelation = new Relation(RelationType::ONE_TO_ONE, 'Account');`

Для экономии памяти, да и вообще аккуратности кода, стоит использовать уже описанную связь в $relations:

`$this->treeRelation = $this->relations['Account'];`