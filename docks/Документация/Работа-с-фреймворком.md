Здесь рассматривается процесс настройки и запуска фреймворка от окончания установки пакетов в системе и до полного запуска, а также то, как происходит процесс запуска демонов.

Перед началом работы нужно запустить контейнеры командой vmng start, так как всё окружение, необходимое для дальнейшей работы находится внутри контейнеров, включая препроцессор PHP и composer. На хост-системе находится только PHPStorm, браузер и Postman.

## Конфигурирование
Проект состоит как минимум из двух частей: проксирующего сервиса web и по крайней мере одного микросервиса, где содержится бизнес-логика приложения.

Проекты хранятся в директории /var/www контейнера backend. По-умолчанию /var/www контейнера backend совпадает с директорией /var/www хост-системы. Первоначальная установка проекта, в котором будут устанавливаться новые сервисы, делается командой:

`pmng np имя_проекта`

Где имя_проекта - это название директории, куда будет установлен проект. Туда добавляется по-умолчанию сервис web. Далее, в .env микросервиса web нужно установить переменную `UNIT_PORT`, которая будет использована для конфигурирования сервера nginx unit.

Для написания кода сервис web не используется. Код пишется внутри микросервисов, которые создаются командой

`pmng ns имя_сервиса`

Где имя_сервиса - это название директории в вашем проекте, где хранится этот микросервис. Далее будет запрошены имя микросервиса и имя базы данных. Удобно, если все три переменные совпадают (имя директории сервиса, имя сервиса и имя базы данных). В одном окружении у сервисов не может быть одного и того же имени. Например, для проекта myProject, микросервис с именем newService будет создан командой

`pmng ns myProject/newService`

Чтобы демон сервиса фреймворка стартовал автоматически, следует указать в его файле .env

`DAEMON=true`

База данных создаётся отдельно командой

`pmng createdb имя_базы_данных`

Чтобы создать микросервис авторизации, вместо `pmng ns` используется следующая команда:

`pmng nas myProject/auth`

Отдельно настраивается конфигурация проксирующего сервера nginx. См. ~/smart-world/config/nginx. Без настройки nginx не получится получить доступ к сервисам. После переконфигурирования nginx следует перезапустить его контейнер, по-умолчанию это frontend, командой

`vmng restart frontend`

## Процесс запуска сервисов
Система запуска сервисов полностью автоматизирована: при запуске контейнера автоматически настраивается и запускается сервер nginx unit, автоматически запускаются демоны фреймворка.

Запуск сервисов внутри контейнера backend осуществляется при помощи мастер-демона supervisor, для которого собирается информация с .env файлов всех микросервисов директории /var/www в контейнере, у которых в .env указано `DAEMON=true`.

## Управление демонами

Демоны фреймворка запускаются автоматически внутри контейнера. Для их управления существует мастер-процесс. Вручную управление демонами осуществляется при помощи утилиты supervisorctl из-под суперпользователя внутри контейнера. У утилиты pmng есть команда ra которая перезапускает сервис, не нужно для этого перезапускать контейнер. Команда перезапуска выглядит так:

`pmng ra project/service`

Это перезапустит сервис, находящийся в директории /var/www/project/service в контейнере. При использовании supervisorctl используется подчёркивание вместо символа дроби “/”. То есть команда будет выглядеть так:

`supervisorctl restart project_service`

Мастер-процесс запускается командой

`artisan mq:run _`

Этот процесс следит за списком очередей сообщений и на каждый из них создаёт свой отдельный процесс, работающий только с одной очередью. Как только в списке очередей сообщений пропадает какая-либо очередь, процесс, слушающий эту очередь, автоматически выходит.

## Очереди и порядок обработки

Управление очередями сообщений осуществляется командой `mq:pool`, с параметрами:

* -l - список очередей
* -c poolName - создать очередь с именем poolName
* -k poolName- удалить очередь с именем poolName

Отдельно каждый процесс-слушатель очереди может быть запущен вручную, например при отладке.

`artisan mq:run queueName`

Для каждой отдельной модели существует свой отдельный слушатель с именованием _model_ModelName, например для модели Account название очереди будет выглядеть _model_Account. Такие очереди для моделей создаются автоматически, смотрите документацию по настройкам окружения для получения информации о том как этим управлять. При запуске нескольких слушателей на одну очередь, обработка сообщения будет случайным свободным процессом-слушателем, но так делать не рекомендуется.

К очередям, которые не относятся к конкретной модели, можно обращаться через URL:

http://hostname/serviceName-queueName/Model/method

Таким образом будет создана очередь, и, если её не существует, для неё будет создан отдельный слушатель.

### Updated 21.10.2020:

Очередь сообщений теперь работает отдельно от основного редиса. Причина в том, что микросервисов может быть много, а микросервис `web` - один. Микросервис web не может поддерживать сотнисерверов `Redis`, поэтому для очередей - отдельный редис. Надо добавить в `config/databases`:

```
    'queue' => [
        'client' => env('REDIS_CLIENT', 'phpredis'),
        'default' => [
            'host' => env('QUEUE_HOST', '127.0.0.1'),
            'password' => env('QUEUE_PASSWORD', null),
            'port' => env('QUEUE_PORT', 6379),
            'database' => env('QUEUE_DB', 0),
        ],
    ],
```

И в `.env`:

```QUEUE_HOST=keydb```

`PID` файла больше нет, это ограничение снято, так как любая очередь может обрабатываться параллельно. Если потребуется `PID`-файл, его можно быстро восстановить, просмотрев логи `git` по ключевому слову `PID`. Этот файл может быть нужен чтобы блокировать запуск двух копий на одном контейнере, в таком случае его стоит перенести в одну из директорий `/run`.

Конфигурация микросервисов позволяет выполнять блокировку очередей. Для этого появился файл `app/pools.json` и расширена команда `artisan mq:pools`:

* -a - добавить очередь, которую можно слушать
* -d - удалить очередь
* -m - список слушаемых очередей

Если файл `pools.json` отсутствует, то обслуживаться будут все доступные очереди, иначе только те, которые присутствуют в `pools.json`.


## Генерация API

Во фреймворке существует автоматическая генерация API и прав доступа. API автоматически генерируется при запуске мастер-процесса. Если не запустить мастер-процесс, создать модель, наполнить её функционалом и запустить отдельного слушателя вручную, то данный функционал не будет доступен извне, так как API для него не будет сгенерировано.