Используя Egal Framework, нужно учитывать, что он создан не совсем по классической схеме, а с целью оптимизации
процессов разработки. Фреймворк использует декларативный подход к программированию, что обеспечивает высокую степень
генерации кода и API, а так же увеличивает скорость разработки.

Docker-контейнеры
===

Для изоляции среды выполнения и её универсализации используются контейнеры docker, в которых происходит вся работа
кода в изоляции от настроек рабочей станции или сервера. В контейнерах уже настроено рабочее окружение, идентичное
серверу. В контейнеры монтируются директории с локальной машины, это позволяет использовать среду разработки на
локальной машине и, при изменении, иметь идентичный код в контейнере.

Управление контейнерами осуществляется при помощи утилиты vmng, которая, по сути, является высокоуровневой
надстройкой над docker-compose. Стоит иметь в виду то, что контейнеры не запускаются автоматически при старте системы,
для запуска контейнеров нужно выполнить команду

```bash
vmng start
```

Метаданные
===

Метаданные - это данные о том, как функционирует каждая конкретная модель, с чем она связана и так далее. Для генерации
метаданных нужно запустить в терминале:

```bash
./artisan mk:metadata ModelName
```

Затем добавить описания модели, полей, связей и прочее. Эти данные потребуются практически во всём фреймворке.
Начиная от генерации самой модели до множества моментов взаимодействия кода в процессе работы. В том числе, метаданные
нужны для того, чтобы предоставить API для фронтенда.

Маршрутизация
===

Маршруты внутри фреймворка настраиваются автоматически, не нужно прибегать к созданию контроллеров и описанию маршрутов
для создания полезного кода. Маршруты строятся в виде /service/Model/modelMethod/id, что позволяет знать заранее
как будет выглядеть путь к полезному коду.

Модели
===

Модели фреймворка несколько отличаются от моделей Eloquent. Есть модель, наследованная от модели Eloquent, она,
собственно и используется для генерации моделей приложений фреймворка. Модель настроена таким образом, чтобы была
возможность работать без использования контроллеров, маршрутов и прочего для создания полезного кода. Обращение к
ней идёт по указанному выше пути с передачей дополнительных параметров в GET запросе, а в теле документа можно
указать то, что будет передано непосредственно методу модели в качестве параметров. Для передачи параметров функции,
используется JSON массив, содержащий в себе параметры метода модели.

Модель, кроме всего прочего, содержит в себе такие полезности как message - это сообщение, которое пришло
непосредственно от клиента, metaData - доступ к метаданным модели, cache - доступ к Redis кэшу модели (RedisManager).

После создания метаданных, создать модель можно командой:

```bash
./artisan mk:model ModelName
```

Миграции
===

Миграции генерируются для создания (и только) таблиц в базе данных к моделям на основе метаданных:

```bash
./artisan mk:migration ModelName
```

Остальные миграции генерируются при помощи стандартной команды artisan

```bash
./artisan make:migration
```

Роли
===

Во фреймворке есть поддержка ролевого доступа к системе, по-умолчанию она включена и для каждого метода модели
определяются роли, которым этот метод будет доступен. Например следующий метод будет доступен залогиневшемуся
пользователю и админу:

```php
/**
 * @roles @logged, admin
 */
public function xXx() {
}
```

А вот пример для доступа к методам, находящимся в наследуемом классе:

```bash
/**
 * @method-roles methodOne admin
 * @method-roles methodTwo @all
 */
class xOxOxO {
}
```

По-умолчанию, методы недоступны из-вне. Для того, чтобы пользователи с соответствующими ролями могли использовать
код метода, нужно их обязательно прописать, либо отключить систему авторизации (ВНИМАНИЕ! Это небезопасно давать
доступ всем к модели). Для отключения ролевого доступа используется константа окружения `DISABLE_AUTH=true`, её
можно использовать только на локальной машине разработчика, ни в коем случае не на боевом сервере.

Роли хранятся на сервере авторизации kerberos. Можно обойтись и без него, если не нужно входить в систему по каким-то
причинам, и использовать везде @all в ролевой системе. Сервер авторизации должен быть отдельным самостоятельным
сервером. Желательно изолированным, закопанным на глубину 2км и без доступа к интернету. Но разумно его держать
на отдельном защищённом сервере. Чтобы установить сервер авторизации, нужно выполнить команду:

```bash
./artisan init_auth
```

На сервере авторизации не стоит держать что-то кроме сервера авторизации. Роли и данные о пользователе придут в
мандате, который лежит в $model->message.
