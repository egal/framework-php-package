## Настройка сервиса аутентификации

Для разграничения доступа пользователей, нам нужно создать сервис аутентификации. Предположим что у нас уже имеется проект с названием project. Для создания сервиса аутентификации нужно выполнить следующую команду:

```shell
pmng nas project/auth
```

Далее надо будет создать базу данных, и запустить миграции:

```shell
pmng createdb auth
```

```shell
pmng a project/auth migrate
```

## Конфигурирование

Конфигурация сервиса auth находитс в файле .env:

Время жизни мандата в секундах, по его истечении надо будет аутентифицироваться заново. У мандата время жизни каждый раз обновляется при обращении.

`SESSION_TTL=900`

После настройки перезапускаем контейнер backend командой:

```shell
vmng restart backend
```

Перезапуск контейнера нужен для автоматической настройки конфигурационных файлов контейнера на новый проект. Это происходит при запуске контейнера.

## Роли и пользователи

Создать роль можно следующей командой:

```shell
pmng a project/auth auth:create_role Admin admin 0
```

Здесь:
Первый параметр к команде - это человекочитаемое название роли “Admin”,
второй - внутреннее имя, которое будет использоваться в коде (для внутреннего имени не должно быть пробелов и специальных символов),
а третий - "0" это то, что эта роль не будет (1 - будет) присваиваться новому пользователю по-умолчанию.

Регистрируем нового пользователя из консоли:

```shell
curl -iLXPOST http://localhost/auth/User/register -d '["Admin", "admin@mail.com", "password"]'
```

Также это можно сделать командами artisan:

```shell
pmng a libProject/auth auth:create_user Admin admin@mail.com password
pmng a libProject/auth auth:set_group admin@mail.com admin
```

Роль по-умолчанию автоматически не назначается, если добавлять пользователя через консоль.

## Настройка прав доступа

Права доступа настраиваются в комментариях PHPDoc моделей, которые хранятся в app/PublicModels. Пример настроек есть в каждой модели на основные CRUD методы:

```php
/**
* @method-roles create admin
* @method-roles update admin
* @method-roles delete admin
* @method-roles getItem admin
* @method-roles getItems admin
* @method-roles getTree admin
*/
```

Роли перечисляются через запятую.

Так-же существует несколько системных ролей:
- `@all` - работает для всех пользователей ресурса, даже не авторизованных в системе
- `@logged` - только для авторизованных
- `@self` - при обращении микросервиса самому к себе
- `@service` - если это другой микросервис

## Авторизация

Для авторизации используется токен вида:

```
{"email":"admin@mail.com","data":"{\"data\":\"oj4kVXrsdOyVjrLkZBEQgA==\",\"initVector\":\"b8280da8ecf74baaff9c8e21f7d52969\",\"salt\":\"6be25138e373a930\"}"}
```

Чтобы авторизоваться нужно передавать заголовок “Authorization: bearer” с сгенерированным токеном

```shell
curl -iLXPOST http://localhost/library/Book/getItems -H 'Authorization: bearer {"email":"admin@mail.com","data":"{\"data\":\"oj4kVXrsdOyVjrLkZBEQgA==\",\"initVector\":\"b8280da8ecf74baaff9c8e21f7d52969\",\"salt\":\"6be25138e373a930\"}"}'
```

И с этим заголовком надо будет делать каждый запрос для доступа к закрытым точкам входа API.

Логин
```shell
curl -iLXPOST http://localhost/auth/User/login -d '[{"email":"admin@mail.com","data": "{\"data\":\"21TOEE10sjDisoU0jFvWyQ==\",\"initVector\":\"1e74e35896cbea314f6077fb87ef2c55\",\"salt\":\"b3b1629b2b71fa27\"}"}]'
```

Смена email
```shell
curl -iLXPOST http://localhost/auth/User/changeEmail -H 'Authorization: bearer {"email":"admin@mail.com", "data": "{\"data\":\"QRpECXGqc\\\/48JkxtMcga+g==\",\"initVector\":\"6323b9313c4a0bf78be2c1c8a5060d16\",\"salt\":\"f55678536610e76b\"}"}' -d '["admin@mail.com", "admin@mail.ru"]'
```

Смена пароля
```shell
curl -iLXPOST http://localhost/auth/User/changePassword -H 'Authorization: bearer {"email":"admin@mail.com","data":"{\"data\":\"TLPKe6dcmG\\\/dZxK3mCOM+w==\",\"initVector\":\"233969eccd18826d2d2f26b215ed95ba\",\"salt\":\"091326beaf495cbf\"}"}' -d '["admin@mail.com", "password"]'
```

А так-же подтверждение email

```
http://localhost/auth/User/emailConfirm
```

Выход

```
http://localhost/auth/User/logout
```

## Аутентификация сервисов

Для того, чтобы сервисы могли общаться между друг другом, нужно дать им возможность аутентифицироваться в системе. За это также отвечает сервис аутентификации. Дело в том, что сервисам будет отказано в получении мандата пользователя, если они не могут авторизоваться. А мандат пользователя нужен для того, чтобы идентифицировать пользователя на конечном сервисе и дать доступ к закрытым точкам входа.

Для этого нужно создать пользователя для каждого микросервиса, используемого в системе, кроме сервиса аутентификации и сервиса web. В этом поможет следующая команда artisan:

```shell
pmng a libProject/auth auth:create_service library ServerSecretPassword
```

Где ServerSecretPassword - это запись в .env APP_KEY сервиса library. У каждого микросервиса должен быть свой собственный ключ.

## Аутентификация в системе из консоли

Аутентификация нужна для того, чтобы связать пользователя с аккаунтом, а авторизация - для того чтобы получить доступ к приватным точкам входа сервиса.

При использовании фронтенд части проблем никаких не будет, там всё уже есть, а для тестирования из консоли будет всё посложнее, так как используется протокол Kerberos.

Сначала надо аутентифицироваться. Для этого нам поможет PHP скрипт, который нужно сохранить в /var/www/login.php:

```php
<?php

$login = 'admin@mail.com';
$pass = password;

$salt = openssl_random_pseudo_bytes(8);
$salted = '';
$dx = '';
while (strlen($salted) < 48) {
    $dx = md5($dx . $pass . $salt, true);
    $salted .= $dx;
}
$iv = substr($salted, 32, 16);
$encryptedData = openssl_encrypt(
    json_encode(time()), 'AES-256-CBC', substr($salted, 0, 32), true, $iv
);
echo json_encode([
    'email' => $login,
    'data' => json_encode([
        'data' => base64_encode($encryptedData),
        'initVector' => bin2hex($iv),
        'salt' => bin2hex($salt)
    ])
])."\n";
```

Этот скрипт создаст токен, который будет использоваться для аутентификации и авторизации. Заходим в контейнер backend:

```shell
vmng login backend
```

И выполняем команду:

```shell
php login.php
```

Она сгенерирует токен вида:

```
{"email":"admin@mail.com","data":"{\"data\":\"oj4kVXrsdOyVjrLkZBEQgA==\",\"initVector\":\"b8280da8ecf74baaff9c8e21f7d52969\",\"salt\":\"6be25138e373a930\"}"}
```

Дальше используем его для аутентификации в системе:

```shell
curl -iLXPOST http://localhost/auth/User/login -d ‘{"email":"admin@mail.com","data":"{\"data\":\"oj4kVXrsdOyVjrLkZBEQgA==\",\"initVector\":\"b8280da8ecf74baaff9c8e21f7d52969\",\"salt\":\"6be25138e373a930\"}"}’
```

Если пришёл ответ похожий на тот что ниже, значит вы успешно аутентифицировались в системе:

```
HTTP/1.1 200 OK
Server: nginx/1.17.10
Date: Tue, 08 Sep 2020 09:53:02 GMT
Content-Type: application/json
Transfer-Encoding: chunked
Connection: keep-alive
X-Powered-By: PHP/7.4.3
Access-Control-Allow-Origin: *
Access-Control-Allow-Headers: *
Cache-Control: private, must-revalidate
pragma: no-cache
expires: -1

{
    "uid": "b23db260-ab5d-4f29-b6c7-2bdc65292939",
    "model": "User",
    "action": "login",
    "data": {
        "sessionKey": {
            "email": "admin@mail.com",
            "data": "{\"data\":\"oj4kVXrsdOyVjrLkZBEQgA==\",\"initVector\":\"b8280da8ecf74baaff9c8e21f7d52969\",\"salt\":\"6be25138e373a930\"}"
        },
        "data": "{\"data\":\"l5Q\\\/dY5n4mzx1i7VLa3IDQ==\",\"initVector\":\"d33a056d6970b688f0c88505d9b2892c\",\"salt\":\"7e9a190da20b87eb\"}"
    },
    "processTime": 0.012946844100952148,
    "hash": "27a1a9108983a3457b169dedea50ca67d1b9e7328a08b7608b517c3f12d82368",
    "method": 2
}
```

Тут есть маленький нюанс: для токена используется флаг JSON_UNESCAPED_SLASHES в функции json_encode для совместимости с фронтендом, поэтому в консоли со слешами надо осторожнее. Если токен был создан со слешем в поле data->data, то может возвращаться ошибка “Please, re-login”. Эта проблема касается только скриптования в консольном интерфейсе.
