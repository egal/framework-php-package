Здесь описываются основные паттерны, которые используются во фреймворке. Паттерны, относящиеся к Laravel и PHP, не включены в описание, а также паттерны, которые могут быть использованы в конечных проектах на конкретных задачах и не имеют отношения к самому фреймворку. Также не указываются очевидные вещи, такие как объектно-ориентированный подход и активная запись.

Фреймворк создан для клиент-серверных приложений. Это значит, что в проекте есть клиентская и серверная части и данные между ними передаются по сети. Также по сети передаются данные между микросервисами.

Во фреймворке есть центральная часть, это микросервис web. Он предназначен для обмена данными между клиентом и микросервисами. Сами микросервисы при этом вполне способны общаться между собой как через web посредством HTTP запросов, так и самостоятельно, этот паттерн называется “Смешанный способ взаимодействия”.

Взаимодействие между системами осуществляется на основе объектной модели, в которой в объект Message могут быть включены другие объекты или данные. Этот паттерн называется “Интеграция на основе единой понятийной модели предметной области”.

Система взаимодействует между компонентами через шину данных, в качестве которой используется Redis. В редисе формируется пул сообщений, который обрабатывается микросервисами фреймворка. Паттерн называется “Обмен сообщениями”.

Во фреймворке возможно использовать конвейерную обработку данных. Задачи распределяются по очередям, которые обрабатываются по очереди сообщение за сообщением. Это позволит произвести последовательную обработку команд в строго установленном порядке. При использовании различных моделей для пула последовательных запросов может быть сформирована отдельная очередь.

У каждого микросервиса есть Диспетчер, он позволяет запускать и останавливать обработчики очередей сообщений. Очереди обрабатываются параллельно, каждая очередь обрабатывается последовательно.

Паттерн “Одиночка” используется в демонах обработки очередей. Один демон на очередь, это класс ProcessQueue. Если создать несколько обработчиков одной очереди - может быть конфликт между разными версиями кода.

В системе используется паттерн “Сохранение сеанса на стороне клиента”. Это значит, что сервер не участвует в определении состояния сессии клиента, это состояние сохраняется на стороне клиента. Сервер ничего не знает о клиенте (за исключением того, что содержится в мандате сервиса авторизации), это упрощает логику сервера.

Также используется паттерн “Прокси”. Существует класс с данными, который хранить в памяти смысла нет. Существует другой класс, по обращении к которому создаётся жирный объект.

Паттерн “Мост” используется для разделения абстракции и реализации. В библиотеке common лежат интерфейсы, на базе которых должны реализовываться классы. Эти классы реализуются в других библиотеках. Некоторые сущности предоставляют возможность создания объектов классов с заданным интерфейсом, это паттерн “Создатель экземпляров класса”. Таким образом реализуется паттерн “Устойчивый к изменениям”, почти все публично доступные классы должны реализовывать интерфейс.

Считается правильным, если каждая библиотека фреймворка использует интерфейсы из библиотеки common, а не непосредственно библиотеки с реализацией. Этот паттерн называется “Низкая связанность”. Этот паттерн также используется для обеспечения работы системы, в случае если отключается один из микросервисов.

Во фреймворке реализован паттерн “Шаблонный метод”. Это значит, что методы внутри классов разбиты на более мелкие и могут быть переопределены со своей собственной логикой. А для валидации используется шаблонная функция, которая может быть переопределена в зависимости от ситуации (см. bootstrap/egal.php).

Мы используем паттерн “Жирные модели”. Это значит, что у нас нет контроллеров, вся бизнес-логика полностью ложится на модели. Смысл в этом такой, что вся бизнес-логика содержится в одном месте, не разбивается в модели и контроллеры, что убирает сомнения в том, куда складывать код. Кроме этого, API автоматически строится до методов модели, что убирает вообще необходимость в контроллерах.

Во фреймворке используется декларативный способ программирования. Это значит, что структура и поведение системы частично описывается в метаданных, которые могут быть использованы для множества различных структур во фреймворке. Начиная от генерации базовых моделей и метаданных, заканчивая генерацией меню и API.