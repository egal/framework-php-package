## Задача

По шагам создать каталог книг с авторами, жанрами и книгами. Должна быть возможность редактирования. Книги и авторы - отношение многие ко многим, жанры и книги - отношение один ко многим. То есть, у книги может быть несколько авторов, а жанр может быть только один. Поиск книг по жанрам и авторам.

## Перед началом
- Убедитесь что ваша среда соответствует [требованиям](Требования)

## Настройка окружения
- Скачать скрипт по [ссылке](https://gitlab.smartworld.team:3443/egal-framework/installer/-/blob/master/eg-installer.sh) (нажав кнопку скачивания справа сверху)
- Запустить:
 - `cd DOWNLOAD_FOLDER`
 - `bash ./eg-installer.sh`
- Следовать дальнейшим инструкциям

Альтернативный путь настройки окружения доступен по [ссылке](Основы/Настройка окружения)

## Установка и настройка проектов и микросервисов

Проекты хранятся в директории /var/www контейнера backend. 

Для создания нового проекта нужно выполнить
```pmng np libProject```

Эта команда создаст директорию /var/www/libProject, а также установит сервис web.

Настраиваем сервис web (если нужно)

В файл `/var/www/libProject/web/.env` нужно установить нужный порт для unit 

```UNIT_PORT=8303```

## Конфигурация nginx

Отдельно настраивается конфигурация проксирующего сервера nginx. См. ~/smart-world/config/nginx. 
Без настройки nginx не получится получить доступ к сервисам. После переконфигурирования nginx следует перезапустить контейнер frontend, командой

```vmng restart frontend```

## Установка и настройка микросервиса library

Для написания кода сервис web не используется. Код пишется внутри микросервисов.

```pmng ns libProject/library```

Далее необходимо ввести название микросервиса либо просто нажать enter.
`What service name should be? [library]:`

Аналогично для базы данных

`What DB name should be? [library]`

Далее необходимо добавить строки в файл .env микросервиса

`QUEUE_HOST=keydb`

Чтобы демон сервиса фреймворка стартовал автоматически, следует указать 

`DAEMON=true`

Чтобы система не просила авторизацию в API, добавляем в .env (более подробнее по [ссылке](https://gitlab.smartworld.team:3443/egal-framework/framework/-/wikis/%D0%94%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F/%D0%9F%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B%20%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20.env#%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F))

`DISABLE_AUTH=true`

Далее создаем базу данных командой

```pmng createdb library```

## Установка и настройка сервиса авторизации (пропустить если не нужен)

Создаем базу данных

```pmng createdb auth```

Чтобы создать микросервис авторизации, вместо pmng ns используется следующая команда:

```pmng nas libProject/auth```

Запускаем миграции 

```pmng a libProject/auth migrate```

В .evn файл добавляем

`QUEUE_HOST=keydb`


## Авторы и жанры

Создаём метаданные для авторов командой:

```bash
pmng a libProject/library mk:metadata Author
```

Команда `pmng a` - это вызов artisan в конкретном микросервисе, в данном случае это libProject/library. Данная команда создаст файл метаданных library/app/Metadata/Author.php, который будет выглядеть примерно так:

```php
<?php

namespace App\Metadata;

use EgalFramework\Common\FieldType;
use EgalFramework\Metadata\Field;
use EgalFramework\Metadata\Metadata;

/**
* Class Author
* @package App\Metadata
*/
class Author extends Metadata
{

   /** @var string */
   protected string $label = 'Label';

   /** @var string */
   protected string $table = 'authors';

   /**
    * Author constructor.
    */
   public function __construct()
   {
       $this->data = [
           'id' => (new Field(FieldType::PK, '#'))
               ->setInChangeForm(false)
               ->setInCreateForm(false),
           'created_at' => (new Field(FieldType::DATETIME, 'Created'))
               ->setInChangeForm(false)
               ->setInCreateForm(false),
           'updated_at' => (new Field(FieldType::DATETIME, 'Modified'))
               ->setInChangeForm(false)
               ->setInCreateForm(false),
           'hash' => (new Field(FieldType::STRING, 'hash'))
               ->setRequired(true),
       ];
       parent::__construct();
   }

}
```

Это типовой шаблон метаданных, с которым мы будем дальше работать. Сущность автора может содержать имя автора, нам больше пока не нужно. Поэтому добавляем к стандартным полям в массиве $this->data следующее:

```php
'name' => new Field(FieldType::STRING, 'Name'),
```

Удобнее всего вставлять поля сущности после описания поля id (между id и created_at). Идентификатор идёт первым, а служебные поля в конце.

Дальше генерируем модель и миграцию:

```bash
pmng a libProject/library mk:model Author
pmng a libProject/library mk:migration Author
```

Для жанров заполняем всё точно так же, как и с авторами. Название жанра на английском языке Genre.

## Книги

Создаём метаданные книг:

```bash
pmng a libProject/library mk:metadata Book
```

Заполняем полями:

```php
'name' => new Field(FieldType::STRING, 'Name'),
'description' => new Field(FieldType::TEXT, 'Description'),
'genre_id' => (new Field(FieldType::RELATION, 'Genre'))
   ->setRelation('GenreRelation')
   ->setRequired(true),
```

Поле genre_id будет у нас ссылаться на жанр, так как он у нас один ко многим. Метод поля setRelation устанавливает связь между полем и отношением. Отношения описываются отдельно. Ниже, под инициализацией массива $this->data, нужно инициализировать массив отношений:

```php
$this->relations = [
   'GenreRelation' => new Relation(RelationType::BELONGS_TO, 'Genre'),
];
```

Массив отношений позволяет указать тип отношений и модель, с которой идёт связь. Отношение между книгами и авторами будет описано ниже.

Дальше инициализируем модель и миграцию как было выше:

```bash
pmng a libProject/library mk:model Book
pmng a libProject/library mk:migration Book
```

## Связь книги-авторы

Связь многие ко многим требует использования промежуточной таблицы. А для того, чтобы можно было без дополнительного кода искать по связям, нужно будет создать отдельную модель. Назовём её BookAuthor. Все команды дальше точно такие же, как и для других моделей, а метаданные нужно дополнить связями между другими таблицами:

```php
'book_id' => (new Field(FieldType::RELATION, 'Book'))
   ->setRequired(true)
   ->setRelation('BookRelation'),
'author_id' => (new Field(FieldType::RELATION, 'Author'))
   ->setRequired(true)
   ->setRelation('AuthorRelation'),
```

И массив $this->realtions:

```php
$this->relations = [
   'BookRelation' => new Relation(RelationType::BELONGS_TO, 'Book'),
   'AuthorRelation' => new Relation(RelationType::BELONGS_TO, 'Author'),
];
```

## Запуск

Для начала запустим миграции:

```bash
pmng a libProject/library migrate
```

И перезапустим микросервис нашей библиотеки:

```bash
pmng ra libProject/library
```

Для проверки запускаем команду:

```bash
curl -iLXPOST http://localhost/library/Book/getItems
```

И увидим такое сообщение в ответ:

```
HTTP/1.1 200 OK
Server: nginx/1.17.10
Date: Tue, 08 Sep 2020 09:20:42 GMT
Content-Type: application/json
Transfer-Encoding: chunked
Connection: keep-alive
X-Powered-By: PHP/7.4.3
Access-Control-Allow-Origin: *
Access-Control-Allow-Headers: *
Cache-Control: private, must-revalidate
pragma: no-cache
expires: -1

{
    "uid": "82b22a4a-4a97-4ff5-9646-7f0400411884",
    "model": "Book",
    "action": "getItems",
    "data": {
        "items": [],
        "count": 0
    },
    "processTime": 0.026002883911132812,
    "hash": "66b458882c920674d1388a6bc646cfa93a1146c0d211c54a1e93334a25c35f5e",
    "method": 2
}
```

В поле “items” пустой массив, это значит, что у нас нет данных в базе. Наполнить базу можно тремя способами:

1. Создать миграцию
1. Использовать фронтенд
1. Наполнить обращениями к сервису прямыми запросами к API

Ниже будет рассмотрен последний вариант.

```bash
curl -iLXPOST http://localhost/library/Book/getItems
```

## Заполнение базы

Заполнить базу из консоли для авторов можно, обратившись к методу модели Author::create:

```bash
curl -iLXPOST http://localhost/library/Author/create -d '[{"name":"Pratchett"}]'
```

Также и для остальных моделей. Для создания связей книга-автор нужно использовать модель BookAuthor.

## Дополнительные настройки

Добавим в метаданные книги поле:

```php
'author' => (new Field(FieldType::RELATION, 'Author'))
   ->setRelation('AuthorRelation'),
```

И отношение:

```php
'AuthorRelation' => new Relation(RelationType::MANY_TO_MANY, 'Author', 'BookAuthor'),
```

Это позволит сортировать по автору. Сортировка по отношениям происходит по полю, указанному в свойстве $viewName метаданных, по-умолчанию это поле “name”. Смотрите запросы ниже.

Для авторов поле:

```php
'book' => (new Field(FieldType::RELATION, 'Book'))
   ->setRelation('BookRelation'),
```

Это поле не будет фигурировать в базе, так как оно ссылается на отношение многие-ко-многим. Оно описывается в массиве relations так:

```php
$this->relations = [
   'BookRelation' => new Relation(RelationType::MANY_TO_MANY, 'Book', 'BookAuthor'),
];
```

Для жанров поле:

```php
'book' => (new Field(FieldType::RELATION, 'Book'))
   ->setRelation('BookRelation'),
```

И отношения:

```php
$this->relations = [
   'BookRelation' => new Relation(RelationType::ONE_TO_MANY, 'Book'),
];
```

Отношения один-ко-многим также игнорируются для базы данных.

## Примеры запросов

Поиск по автору:

```bash
curl -iLXPOST http://localhost/library/Book/getItems?author=3&_with=%5b"AuthorRelation"%5d
```

То же самое по жанру.

Авторы с книгами:

```bash
curl -iLXPOST http://localhost/library/Author/getItems?_with=%5b"BookRelation"%5d
```

Жанры с книгами:

```bash
curl -iLXPOST http://localhost/library/Genre/getItems?_with=%5b"BookRelation"%5d
```
