## Как это работает

Фреймворк обладает клиент-серверной архитектурой, где клиент - это приложение на Vue, которое взаимодействует с API бэкенда, основанное на Lumen (микросервисный фреймворк от создателей Laravel).

Бэкенд содержит в себе несколько инфраструктур, которые позволяют быстро начать работу и не тратить время на настройку системы. Инфраструктуры следующие: контейнерная, микросервисная и программная.

Контейнерная инфраструктура базируется на контейнерах docker и позволяет быстро развернуть рабочую среду и запустить сервис, а также оперативно масштабировать систему, разворачивая контейнеры в том количестве, в котором необходимо для выполнения функции проекта.

Микросервисная инфраструктура фреймворка позволяет быстро масштабировать систему, не будучи зависимым от конкретного железа, распределяя нагрузку равномерно по кластеру.

Программная инфраструктура обеспечивает обработку и хранение данных и передачу их клиенту.

## Контейнеры

Схема работы docker-контейнеров выглядит следующим образом:

![network](uploads/86cafa4694ca758fb15e46648e213dd9/network.png)

Клиент обращается к фронтенд-серверу nginx, который проксирует запрос к бэкенду, который, в свою очередь, работает с базой данных и редисом.

Веб-сервер nginx - это проксирующий веб-сервер, который нужен для двух вещей:

1. Обеспечение распределения нагрузки, в случае, если это высоконагруженный сервер
1. Снижение нагрузки на сервер приложений nginx unit

Если с первым пунктом всё понятно, то второй стоит пояснить. Сервер приложений обрабатывает данные от пользователя, и, пока не отдаст их клиенту, будет держать процесс в памяти, сколько бы тот её не занимал. Соединение между клиентом и сервером может быть разным, скорость может варьироваться по-разному. Проксирующий сервер nginx позволяет быстро получить данные от сервера приложений и, не требуя много памяти, отдаёт её пользователю.

Есть, конечно, и другие преимущества и особенности такой связки, но здесь они рассматриваться не будут.

Контейнер backend - это сервер приложений, на котором работают процессы фреймворка. Там установлен nginx unit, php, composer и прочие программные средства, которые позволяют работать микросервисам фреймворка. Таких контейнеров может быть много.

## Микросервисы

Микросервисная архитектура нужна для того, чтобы распределять нагрузку на аппаратную часть и создать [слабое связывание](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) между сервисами. Этот паттерн используется во всём фреймворке и является предпочтительным начиная от инфраструктуры и заканчивая написанием библиотек. Выглядит это так:

![services](uploads/42c0265a3e4181cada8c6cf737403bc0/services.png)

Всего существует 2 типа микросервисов: это web и service. Масштабирование системы на данном этапе может достигаться путём увеличения количества микросервисов.

### Сервис web

Сервис web предназначен для того, чтобы получать данные по протоколу HTTP, обрабатывать их и передавать через сервис publisher-subscriber остальным микросервисам на обработку в определённом формате. Таких сервисов может быть много в случае, если происходит большое количество запросов к системе.

### Микросервис

Каждый такой сервис предназначен для своей индивидуальной задачи, которая задаётся архитектурой проекта. Таких сервисов может быть много, они могут взаимодействовать между собой и выполнять разные задачи.

### Сервис аутентификации

Этот тип микросервиса такой же как и предыдущий, но был вынесен отдельно, так как настраивается специфическим образом. Он используется только для регистрации и аутентификации пользователя, а авторизация выполняется на конечном микросервисе. Сервис аутентификации для других задач не должен использоваться и должен быть вынесен в отдельный контейнер.

Аутентификация происходит по протоколу Kerberos. Во время регистрации пользователь (фронтенд приложение на Vue), кроме идентификационных данных, отправляет хэш пароля. Дальше аутентификация в системе происходит следующим образом:

1. Пользователь отправляет свой идентификатор (например, email) и текущую метку времени, зашифрованную хэшем своего пароля (это будет токеном для входа пользователя в систему)
1. Сервер расшифровывает метку времени хэшем пароля пользователя
1. Если метка времени на сервере различается больше чем на 5 минут, то аутентификация пользователя не прошла
1. Сервер аутентификации создаёт мандат сервера, к которому хочет обратиться пользователь и сохраняет его в оперативной памяти
1. Сервер аутентификации отправляет обратно зашифрованную хэшем пароля пользователя текущую метку времени на сервере
1. Клиент расшифровывает метку времени и осуществляет такую же проверку на различие на 5 минут
1. Если всё хорошо - аутентификация прошла успешно, дальше пользователь работает с конечным микросервисом, используя токен из первого пункта

Авторизация происходит на конечном микросервисе, который при обращении к нему запрашивает мандат на сервисе аутентификации, если мандат есть - значит пользователь авторизован, если нет - будет выдана ошибка авторизации. Сервис аутентификации автоматически обновляет время жизни мандата при обращении к нему.

## Программная инфраструктура

Единственный сервис, который слушает HTTP, это микросервис web. Остальные микросервисы работают в режиме демонов и слушают очередь сообщений, обрабатывая каждое сообщение одно за другим. Точка входа в микросервис может быть переопределена и идти, например, по протоколу HTTP, однако основным методом общения между сервисами остаётся pub/sub.

Запуск демонов микросервисов происходит следующим образом:

1. Запускается мастер-демон
1. Сканирует проект на PHPDoc
1. Формирует API, которое складывает в Redis
1. Считывает список очередей для запуска
1. Запускает отдельного демона на каждую очередь
1. Если появляется новая очередь - запускает нового демона для неё

Каждый дочерний демон слушает только свою очередь и обрабатывает её в порядке поступления в неё сообщений. В случае, если очередь пропала из списка очередей, демон завершает свою работу.

По-умолчанию сервисы выделяют отдельную очередь на каждую модель. Это можно перенастроить и начать обслуживать очереди, независимые от моделей и обращаться к ним, введя определённый URL в браузере (или сформировав сообщение определённым образом для pub/sub). Все очереди контролируются, есть несколько режимов контроля:

* auto - при каждом запросе сервис будет создавать очередь, если её нет
* semi - полуавтоматический режим, очереди создаются автоматически только для моделей
* manual - полностью ручной режим, где очереди создаются только вручную

Эта настройка делается в зависимости от требований безопасности. Тут нужно понимать, что чем больше очередей - тем больше демонов будет запущено, тем больше памяти будет занято. Для машины разработчика вполне подходит режим auto, для большинства сервисов - режим semi, для сервисов, которым нужен повышенный уровень безопасности - режим manual.